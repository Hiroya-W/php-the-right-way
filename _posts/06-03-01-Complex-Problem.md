---
title: 複雑な問題
isChild: true
anchor:  complex_problem
---

## 複雑な問題 {#complex_problem_title}

これまでに依存性の注入について調べたことがある人なら、
*"制御の反転（IoC：Inversion of Control）"* や *"依存関係逆転の原則（DIP：Dependency Inversion Principle）"*
といった言葉に見覚えがあるだろう。これらは複雑な問題で、依存性の注入によって解決できるものだ。

### 制御の反転

制御の反転とは、文字通り、システムの「制御を反転」することだ。システム全体の制御を、オブジェクトから切り離したままで行う。
依存性の注入の文脈では、依存関係の制御や作成を、システム内のどこか別の場所でやるってことを意味する。

PHPのフレームワークでも、制御の反転は実現されてきた。でも、実際のところ、何の制御を反転しているのだろう。そして、反転した結果、制御はどこに行ってしまったのだろう。
たとえば、たいていのMVCフレームワークには、あらゆるコントローラの親になる基底コントローラが用意されている。
そして、それを継承しなければ依存関係にアクセスできない。
これはこれで制御の反転だが、でも、依存関係を緩くしたというよりは、単純に依存関係を別の場所に移しただけのことだ。

依存性の注入を使えば、これをもっとすっきりと解決できる。依存関係が必要になったときに、必要なものだけを注入すればいい。
ハードコーディングする必要はない。

### S.O.L.I.D.

#### 単一責任の原則

単一責任の原則は、アクターと高レベルなアーキテクチャーに関するものだ。これは "クラスを変更する理由は、ひとつだけであるべきである" という原則だ。これは、個々のクラスは、ソフトウェアが提供する単一の機能のみについて責任を持つべきであるということだ。このアプローチを採用する最大の利点は、再利用性を高めることができることにある。我々のクラスがひとつのことだけをしていれば、他のプログラムでもそれを変更することなく使う（または再利用）することができる。

#### 開放/閉鎖原則


開放/閉鎖原則(Open/Closed Principle) は、クラス設計と機能の拡張に関するものだ。これは"ソフトウェアの要素(クラスやモジュール、関数など)は、拡張に対しては開いており、修正に対しては閉じているべきである" という原則だ。これは、新しい機能が必要になった時は、既存のコードを変更せず、既存のコードを使って新しいコードを書けるようにクラスやモジュール、関数を設計すべきということだ。実用的な言い方をすると、インターフェイスに従ってクラスを実装し、特定のクラスではなく、インターフェイスを使ってタイプヒントを付けるべきということだ。

このアプローチを採用する最大の利点は、既存のコードを変更することなく、新しい機能をサポートできるよう簡単に拡張できることだ。こうすることで、QA にかかる時間を削減でき、アプリケーションを実質的に壊してしまうリスクや、悪い影響を避けることができる。さらにこうすることで、新しいコードを素早く、自信をもってデプロイできるようになる。

#### リスコフの置換原則

リスコフの置換原則は、サブタイピングと継承に関するものだ。これは "子クラスは、絶対に親クラスの型定義を壊してはいけない" という原則だ。Robert C. Martin の言葉を借りれば "サブタイプは、基底型を代替できなければならない" ということだ。

例をあげよう。`embed()` メソッドを定義したインターフェイス `FileInterface` があるとする。そして、このインターフェイスを実装したクラス `Audio` と `Video` があるとして、`embed()` の使い方は常に期待通りであるとしよう。後になって、`FileInterface` を実装した `PDF` や `Gist` クラスを作ることになっても、`embed()` メソッドが何をするかを我々はわかっているはずだ。このアプローチを採用する最大の利点は、柔軟性があり、簡単に設定可能なプログラムを作れることだ。なぜなら、オブジェクトの型 (ここでは `FileInterface`) を別の型に変更しても、プログラムを変更する必要はないからだ。

#### インターフェイス分離の原則

インターフェイス分離の原則(ISP)とは、ビジネスロジックとクライアントの通信に関するものだ。これは、"どのクライアントも、自分が使わないメソッドに依存してはいけない" という原則だ。これは、全てのクラスが従い、実装する必要がある単一のモノリシックなインターフェイスを持つのではなく、小さな、特定の概念を持つインターフェイスの集合を提供し、クラスはそれらをひとつ以上実装すべきということだ。

例をあげよう。`Car` や `Bus` クラスは `steeringWheel()` メソッドに関心があるとしよう。一方で、`Motorcycle` や `Tricycle` クラスはそのメソッドに関心がないとする。反対に `Motorcycle` や `Tricycle` は `handlebars()` メソッドに関心があるが、`Car` や `Bus`  メソッドはそのメソッドに関心がないとする。この場合、これら全ての車両の型が `steeringWheel()` と `handlebars()` を両方サポートするために、これらのメソッドを実装する必要はない。インターフェイスを分割すべきだ。

#### 依存関係逆転の原則

依存関係逆転の原則は、複数の具象クラスの間では、密結合しないようにする原則だ。これを守ると、異なるクラスを渡すことで、新しい機能を利用できるようになる。
これは *「抽象に依存しろ。具象に依存するな」* という原則だ。
簡単に言うと、依存関係はインターフェイスや抽象クラスに対して設定すべきものであり、それを実装したクラスに対して設定してはいけないってこと。
先ほどの例をこの原則に沿って書き直すと、こんなふうになる。

{% highlight php %}
<?php
namespace Database;

class Database
{
    public function __construct(protected AdapterInterface $adapter)
    {
    }
}

interface AdapterInterface {}

class MysqlAdapter implements AdapterInterface {}
{% endhighlight %}

これで `Database` クラスは、具象クラスではなくインターフェイスに依存するように変わった。で、いったい何がうれしいんだろう。

こんな場面を考えてみよう。君は今、とあるチームの一員として作業をしている。アダプターを作っているのは別のメンバーだ。
最初の例だと、その人がアダプターを完成させるまでは、自分のコードのユニットテストのモックを作れない。
インターフェイスに依存するようにした新しいバージョンだと、そのインターフェイスを使ってモックを作ることができる。
同僚が作るアダプターもそのインターフェイスに沿っているとわかっているからだ。

そんなことより、もっとすばらしいメリットもある。こっちの方式のほうが、コードがずっとスケーラブルになるんだ。
仮に将来、別のデータベースに移行することになったとしよう。
そんな場合でも、このインターフェイスを実装した新しいアダプターを書いたらそれでおしまいだ。
それ以外は何もいじる必要がない。
新しいアダプターがきちんと決まりごとに従っているということを、インターフェイスが保証してくれるからだ。
