---
title: エラー
isChild: true
anchor: errors
---

## エラー {#errors_title}

例外処理を重視するプログラミング言語では、何か問題が起こったらすぐに例外を投げる。
それはそれでいいことではあるが、PHPはそうではなく、「例外処理も使える」プログラミング言語だ。
PHPには例外処理の仕組みがあるし、コアの中でもオブジェクトを扱うときには例外処理を行うことが増えている。
でも、PHPは基本的に、よっぽど致命的なエラーが発生しない限りは何があろうと処理を続行しようとする。

たとえば、こんなコードを考えてみよう。

{% highlight php %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

単純にnoticeレベルのエラーになるだけで、PHPはそのまま処理を続行する。
例外処理を重視する世界からやってきた人にとっては、これは少しキモいと思うかもしれないね。
たとえばPythonなら、未定義の変数を参照しようとすると、例外が発生する。

{% highlight python %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

実際の違いは、こういうことだ。
Pythonは、些細なことにまでこだわることで、プログラマーが余計な心配（「もし○○だったら、その場合は…」と考えたり、エッジケースを考慮したりなど）
をせずに済むようにしている。
一方PHPは、どうしようもないエラーが発生しないかぎりは、一応エラーを報告したうえで処理を続行する。

### エラーの深刻度

PHPのエラーは、何段階かの深刻度レベルに別れている。PHPでよく使われるメッセージの形式は、
エラー（error）と注意（notice）そして警告（warning）だ。
それぞれ別々の深刻度レベルが設定されていて、 `E_ERROR`、`E_NOTICE`、そして `E_WARNING` になる。
「エラー」は実行時の致命的な問題で、ふつうはコードの書きかたがまずいせいで発生する。
これは修正しなければいけない。というのも、これが発生するとPHPの実行がそこで止まってしまうからだ。
「警告」は致命的ではない問題で、スクリプトの実行は止まらない。
「注意」は助言みたいなもので、問題を起こす可能性があるスクリプトを実行したときに発生する。
これもスクリプトの実行は止まらない。

もうひとつ、コンパイル時に発生する `E_STRICT` という形式のメッセージもある。
これは、相互運用性や将来のバージョンのPHPとの互換性を考えたときに、コードを書き換えたほうがいいと提案するためのメッセージだ。

### PHPのエラー報告の挙動の変更

エラー報告の挙動は、PHPの設定で変更することもできるしPHPの関数で変更することもできる。
組み込みの関数 `error_reporting()` にエラーレベル定数を渡せば、そのスクリプトの実行中に
どのレベルのエラー処理をするのかを設定できる。
たとえば、警告(warning)とかエラー(error)は表示させたいけれども、別に注意(notice)は見たくないという場合は、こんなふうにすればいい。

{% highlight php %}
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

画面に表示するかしないか(開発時に有効)だけでなく、ログに出力するかしないか(運用時に有効)も制御できる。
詳細は [エラーレポート][errorreport] を参照。

### Inline Error Suppression

You can also tell PHP to suppress specific errors with the Error Control Operator `@`. You put 
this operator at the beginning of an expression, and any error that's a direct result of the expression is silenced. 

{% highlight php %}
echo @$foo['bar'];
{% endhighlight %}

This will output `$foo['bar']` if it exists, but will simply return a null and print nothing if the variable `$foo` or 
`'bar'` key does not exist.  Without the error control operator, this expression could create a `PHP Notice:  Undefined variable: foo` or `PHP Notice:  Undefined index: bar` error.

This might seem like a good idea, but there are a few undesirable tradeoffs.  PHP handles expressions using an `@` in a less performant way than expressions without an `@`.  Premature optimization may be the root of all programming arguments, but if performance is particularly important for your application/library it's important to understand the error control operator's performance implications. 

Secondly, the error control operator **completely** swallows the error.  The error is not displayed, and the error is not send to the error log. Also, stock/production PHP systems have no way to turn off the error control operator. While you may be correct that the error you're seeing is harmless, a different, less harmless error will be just as silent.  

If there's a way to avoid the error suppression operator, you should consider it.  For example, our code above could be rewritten like this

{% highlight php %}
echo isset($foo['bar']) ? $foo['bar'] : '';
{% endhighlight %}

One instance where error suppression might make sense is where `fopen()` fails to find a file to load. You could check 
for the existence of the file before you try to load it, but if the file is deleted after the check and before the `fopen()` 
(which might sound impossible, but it can happen) then `fopen()` will return false _and_ throw an error. This is
potentially something PHP should resolve, but is one case where error suppression might seem like the only valid 
solution.

Earlier we mentioned there's no way in a stock PHP system to turn off the error control operator.  However, [xDebug] has an `xdebug.scream` ini setting which will disable the error control operator.  You can set this via your `php.ini` file with the following.

    xdebug.scream = On
    
You can also set this value at runtime with the `ini_set` function 

{% highlight php %}
ini_set('xdebug.scream', '1')
{% endhighlight %}

The "[Scream]" PHP extension offers similar functionality to xDebug's, although Scream's ini setting is named `scream.enabled`.

This is most useful when you're debugging code and suspect an informative error is suppressed.  Use scream with care, and as a temporary debugging tool. There's lots of PHP library code that may not work with the error control operator disabled.  


* [エラー制御演算子](http://php.net/manual/ja/language.operators.errorcontrol.php)
* [SitePoint](http://www.sitepoint.com/)
* [xDebug] 
* [Scream]

[xDebug]: http://xdebug.org/docs/basic
[Scream]: http://www.php.net/manual/ja/book.scream.php

### ErrorException

PHP is perfectly capable of being an "exception-heavy" programming language, and only requires a few lines of code to 
make the switch. Basically you can throw your "errors" as "exceptions" using the `ErrorException` class, which extends the `Exception` class.

This is a common practice implemented by a large number of modern frameworks such as Symfony and Laravel. By default 
Laravel will display all errors as exceptions using the [Whoops!] package if the `app.debug` switch is turned on, then 
hide them if the switch is turned off. 

By throwing errors as exceptions in development you can handle them better than the usual result, and if you see an 
exception during development you can wrap it in a catch statement with specific instructions on how to handle the situation. Each exception you catch instantly makes your application that little bit more robust.

More information on this and details on how to use `ErrorException` with error handling can be found at 
[ErrorException Class][errorexception]. 

* [Error Control Operators](http://php.net/manual/en/language.operators.errorcontrol.php)
* [エラー処理用に定義済みの定数](http://www.php.net/manual/ja/errorfunc.constants.php)
* [error_reporting](http://www.php.net/manual/en/function.error-reporting.php)
* [Reporting][errorreport]

[errorexception]: http://php.net/manual/ja/class.errorexception.php
[エラーレポート]: /#error_reporting
[Whoops!]: http://filp.github.io/whoops/
